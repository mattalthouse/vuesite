
<template>
<div>
<head>
	<title>test</title>
	
</head>
<body>
	<input v-on:change="needsUpdate = true;" style="padding: 0px;" type="color" ref="lineColor" value="#e66465" name="LineColor"/>
	<label style="color: white;" for="LineColor">Line Color</label>
	<br/>
	<input v-on:change="needsUpdate = true;" type="range" ref="lineWidth" min="0" max="5" step="0.1" name="LineWidth"/>
	<label style="color: white;" for="LineWidth">Line Width</label>
	<br/>
	<input v-on:change="needsUpdate = true; loadScale = true;" style="color: black;" type="number" ref="modelScale" name="ModelScale"/>
	<label style="color: white;" for="ModelScale">Model Scale (reload)</label>
	<br/>
	<input v-on:change="needsUpdate = true;" onclick="renderPoints = !renderPoints;" type="checkbox" name="DrawPoints" />
    <label style="color: white;" for="DrawPoints">Draw Points</label>
    <br />
	<input v-on:change="needsUpdate = true;" onclick="renderLines = !renderLines;" type="checkbox" name="DrawLines" />
    <label style="color: white;" for="DrawLines">Draw Lines</label>
    <br />
	<input v-on:change="needsUpdate = true;" onclick="renderPolys = !renderPolys;" type="checkbox" name="DrawPolys" />
    <label style="color: white;" for="DrawPolys">Draw Polys</label>
    <br />
	<input v-on:change="needsUpdate = true;" onclick="renderNorms = !renderNorms;" type="checkbox" name="DrawNorms" />
    <label style="color: white;" for="DrawNorms">Draw Normals</label>
    <br />
	<input v-on:change="needsUpdate = true; loadModel = true;" style="color: white;" type="file" ref="fileOBJ" name="FileOBJ"/>
</body>
<canvas id="canvas" ref="canvas"></canvas>
</div>
</template>

<script>
export default {
	name: "3dengine",
	data: function(){
      return{
		// canvas: getElementyByID("canvas"),
		// context: this.$refs['canvas'].getContext('2d'),
		canvas: null,
		context: null,
		width: canvas.width = window.innerWidth,
		height: canvas.height = window.innerHeight,
        fl: 800,
        clipPlane: -2000,
        modelScale: 1,
		light: {x: -500, y: -500, z:-500},
		points: [],
		lines: [],
		normaltemp: [{}],
		polyNormals: [],
		polyNormalIndex: [],
		polyNormalPoints: [],
		dotProdPoints: [],
		lightingPoints: [],
		centroids: [],
		polyobjs: [],
		needsUpdate: true,
		loadModel: false,
		loadScale: false,
		renderPoints: false,
		renderLines: false,
		renderPolys: false,
		renderNorms: false,
		centerZ: 1500,
		fileLoaded: false,
		lineColor: "#affffa",
		lc: this.$refs['lineColor'],
		lineWidth: 0.1,
		lw: this.$refs['lineWidth'],
		fileObj: "",
		filePath: "http://localhost:8080/monkey2.obj",
		fp: this.$refs['fileOBJ'],
		ms: this.$refs['modelScale']
	  }
	},
	mounted: function() {
		this.canvas = document.getElementById('canvas');
 		this.context = x.getContext('2d');
		window.addEventListener("keydown", function(event) {
		switch(event.keyCode) {
			case 37: // left
				if(event.ctrlKey) {
					rotateY(0.05);
				}
				else {
					translateModel(-20, 0, 0);
				}
				break;
			case 39: // right
				if(event.ctrlKey) {
					rotateY(-0.05);
				}
				else {
					translateModel(20, 0, 0);
				}
				break;
			case 38: // up
				if(event.shiftKey) {
					translateModel(0, 0, 20);
				}
				else if(event.ctrlKey) {
					rotateX(0.05);
				}
				else {
					translateModel(0, -20, 0);
				}
				break;
			case 40: // down
				if(event.shiftKey) {
					translateModel(0, 0, -20);
				}
				else if(event.ctrlKey) {
					rotateX(-0.05);
				}
				else {
					translateModel(0, 20, 0);
				}
				break;
			case 87://w
					if(event.shiftKey)
						translateLight(0, 50, 0);
					else
						translateLight(0, 0, 50);
				break;
			case 65: // a
					translateLight(-50, 0, 0);
				break;
			case 83: // s
					if(event.shiftKey)
						translateLight(0, -50, 0);
					else
						translateLight(0, 0, -50);
				break;
			case 68: // d
					translateLight(50, 0, 0);
				break;
		}
	})
	},
  	methods: {
	normalizeNumber: function(val, max, min) { return (val - min) / (max - min); },
	
	getMaxOfArray: function(numArray) {
		  return Math.max.apply(null, numArray);
	},
	getMinOfArray: function(numArray) {
		  return Math.min.apply(null, numArray);
	},
	precise: function(x) {
		  return Number.parseFloat(x.toFixed(2));
	},
	
	
	project: function(pointsList) {
		for(var i = 0; i < pointsList.length; i++) {
			var p = pointsList[i],
                scale = fl / (fl + p.z + centerZ);
				//nscale = fl/ (fl + p.nz + centerZ);

			p.sx = p.x * scale;
			p.sy = p.y * scale;
			// p.nsx = p.nx * nscale;
			// p.nsy = p.ny * nscale;
        }
        //console.log("scale: " + scale + "z " + points[176].z);
	},
	
	dotProduct: function(){
		//debugger;
		dotProdPoints = [];
		var cam = {x: 0, y: 0, z:-2000};

		
		for(i=0; i<this.centroids.length; i++){
			var polyVec = {x: this.centroids[i].x - this.polyNormalPoints[i].x,
						   y: this.centroids[i].y - this.polyNormalPoints[i].y,
						   z: this.centroids[i].z - this.polyNormalPoints[i].z}
						   
			var camVec =  {x: cam.x - this.centroids[i].x,
						   y: cam.y - this.centroids[i].y,
						   z: cam.z - this.centroids[i].z}
						   
			dot = (polyVec.x * camVec.x) + (polyVec.y * camVec.y) + (polyVec.z * camVec.z);
			dotProdPoints.push(dot);
		}
	},
	
	lightingCalc: function(cam){
		//debugger;
		lightingPoints = [];
		//var cam = {x: 0, y: 0, z:-2000};

		
		for(i=0; i<centroids.length; i++){
			var polyVec = {x: centroids[i].x - polyNormalPoints[i].x,
							y: centroids[i].y - polyNormalPoints[i].y,
							z: centroids[i].z - polyNormalPoints[i].z}
							
			var camVec =  {x: cam.x - centroids[i].x,
							y: cam.y - centroids[i].y,
							z: cam.z - centroids[i].z}
							
			dot = (polyVec.x * camVec.x) + (polyVec.y * camVec.y) + (polyVec.z * camVec.z);
			lightingPoints.push(dot);
		}
	},
	
	crossProduct: function(){
		polyNormals = [];
		for(i=0; i< lines.length; i++){
			var p0 = points[lines[i][0]];
			var p1 = points[lines[i][1]];
			var p2 = points[lines[i][2]];
			
			var v1 = {};
			v1.x = (p1.x - p0.x)
			v1.y = (p1.y - p0.y)
			v1.z = (p1.z - p0.z)
			
			var v2 = {};
			v2.x = (p2.x - p0.x)
			v2.y = (p2.y - p0.y)
			v2.z = (p2.z - p0.z) 
			
			var n = {};
			n.x = v1.x * v2.x;
			n.y = v1.y * v2.y;
			n.z = v1.z * v2.z;
			
			var a = {}; //normalized vector
			a.x = n.x/(n.x + n.y + n.z);
			a.y = n.y/(n.x + n.y + n.z);
			a.z = n.z/(n.x + n.y + n.z);
			
			polyNormals.push(a);
			
			
			//debugger;
		}
		
	},
	
	calcNormPts: function(){
		//debugger;
		polyNormalPoints = [];
		centroids = [];
		for(i=0; i < lines.length; i++){
			var p1 = points[lines[i][0]];
			var p2 = points[lines[i][1]];
			var p3 = points[lines[i][2]];
			var pn = polyNormals[polyNormalIndex[i]];
			var tempP = {};
			var centroid = {};
			
			centroid.x = (p1.x + p2.x + p3.x)/3;
			centroid.y = (p1.y + p2.y + p3.y)/3;
			centroid.z = (p1.z + p2.z + p3.z)/3;
			
			tempP.x = centroid.x + pn.x * 100;
			tempP.y = centroid.y + pn.y * 100;
			tempP.z = centroid.z + pn.z * 100;
			
			// var tempNormObj = {};
			// tempNormObj.centroid = centroid;
			// tempNormObj.npoint = tempP;
			polyNormalPoints.push(tempP);
			centroids.push(centroid);
			//debugger;
		}
	},

	// function calcNormal(){
		
		// for	(i = 0; i < lines.length; i++){
			
			// //var n = []
			// for (j = 0; j < lines[i].length; j++) {
				// var p = points[lines[i][j]];
				// var nextpoint = j + i
				// if(nextpoint < lines[i].length){
					// //crossProduct();
					// var np = points[lines[i][nextpoint]];
					// p.nx = (p.y * np.z) - (p.z * np.y);
					// p.ny = (p.z * np.x) - (p.x * np.z);
					// p.nz = (p.x * np.y) - (p.y * np.x);
					// normaltemp.push({x:p.nx, y:p.ny, z:p.nz});
				// }
			// }
			
		// }
		// console.log(normaltemp);
	// },
	
    drawLine: function() {
		context.beginPath();
        for (i = 0; i < lines.length; i++){
			if(dotProdPoints[i] < 0){
				//debugger;
				var p = points[lines[i][0]];
				//scale = fl / (fl + p.z + centerZ);
				if (p.z > clipPlane) {
					//console.log("drawline: " + lines[i])
					//console.log(lines[i][0])
					//console.log(p)

					context.moveTo(p.sx, p.sy);
					for (j = 0; j < lines[i].length; j++) {

						//console.log("p index: " + lines[i][j]);


						var nextpoint = j + 1;
						//var np;
						if (nextpoint < lines[i].length) {
							var p = points[lines[i][nextpoint]]
							//console.log("np index: " + points[i][nextpoint])
							//console.log(p);
							context.lineTo(p.sx, p.sy);
						}

					}
				}
			}

		};
		context.lineWidth = lineWidth;
		context.strokeStyle = lineColor;
		context.stroke();
	},
	drawNormLine: function() {
			//debugger;
			for(i=0; i<polyNormalPoints.length;i++){
				var n = polyNormalPoints[i];
				var p = centroids[i];
				//scale = fl / (fl + p.z + centerZ);
				if (n.z > clipPlane) {
					//console.log("drawline: " + lines[i])
					//console.log(lines[i][0])
					//console.log(p)
					context.beginPath();
					context.moveTo(p.sx, p.sy);
					context.lineTo(n.sx, n.sy);

					context.strokeStyle = "#00FFFF";
					context.stroke();
			}
		};
	},
		// points = [],
		// lines = [],
		// polyNormals = [],
		// polyNormalIndex = [],
		// polyNormalPoints = [],
		// dotProdPoints = [],
		// centroids = [],
	getFullPolyObj: function() {
		polyobjs = [];
		for(i=0; i < lines.length; i++){
			var tempPolyobj = {};
			tempPolyobj.lines = lines[i];
			tempPolyobj.points = [];
				for(j=0; j<lines[i].length; j++){
					tempPolyobj.points.push(points[lines[i][j]])
				}
			tempPolyobj.polyNormal = polyNormals[i];
			tempPolyobj.polyNormalPoint = polyNormalPoints[i];
			tempPolyobj.polyNormalIndex = polyNormalIndex[i];
			tempPolyobj.dotProdPoint = dotProdPoints[i];
			tempPolyobj.centroid = centroids[i];
			tempPolyobj.lightingPoint = lightingPoints[i];
			
			polyobjs.push(tempPolyobj);
		}
	},
	
	sortZ: function(a,b) {
		if (a.centroid.z < b.centroid.z)
			return 1;
		if (a.centroid.z > b.centroid.z)
			return -1;
		return 0;
	},
	
	drawPoly: function() {
		var max = getMaxOfArray(dotProdPoints);
		var min = getMinOfArray(dotProdPoints);
		getFullPolyObj();
		polyobjs.sort(sortZ);
		
        for (i = 0; i < polyobjs.length; i++){
            //debugger;
			if(polyobjs[i].dotProdPoint < 0){
				//var p = points[lines[i][0]];
				var p = polyobjs[i].points[0];
				//scale = fl / (fl + p.z + centerZ);
				if (p.z > clipPlane) {
					//console.log("drawline: " + lines[i])
					//console.log(lines[i][0])
					//console.log(p)
					context.beginPath();
					context.moveTo(p.sx, p.sy);
					for (j = 0; j < polyobjs[i].points.length; j++) {

						//console.log("p index: " + lines[i][j]);


						var nextpoint = j + 1;
						//var np;
						if (nextpoint < polyobjs[i].points.length) {
							var p = polyobjs[i].points[nextpoint]
							//console.log("np index: " + points[i][nextpoint])
							//console.log(p);
							context.lineTo(p.sx, p.sy);
						}

					}
					//debugger;

					//var tempDot = Math.round(normalizeNumber(polyobjs[i].dotProdPoint, min, max) * 10)
					var tempDot = Math.round(normalizeNumber(polyobjs[i].lightingPoint, min, max) * 200) //set scalar to 10 for rough shading, 200 for smooth
					tempDot = tempDot.toString(16);
					
					var fillPolyColor = "#" + tempDot + tempDot + tempDot;  //smooth shading
					//var fillPolyColor = "#"+ tempDot + tempDot + tempDot + tempDot + tempDot + tempDot;  //rough shading
					
					context.strokeStyle = fillPolyColor;
					context.fillStyle = fillPolyColor;
					
					context.lineWidth = 1;
					
					context.stroke();
					context.fill();
				}
			}
		};
	},

	drawPoints: function(){

		var p  = points;
        for (var i = 0; i < points.length; i++){
            //scale = fl / (fl + p[i].z + centerZ);
            if (p[i].z > clipPlane) {
				
				var text = precise(p[i].x) + ", " + precise(p[i].y) + ", " + precise(p[i].z);
				var text = i;
                context.fillRect(p[i].sx, p[i].sy, 5, 5);
				context.font = "12px Arial";
				context.fillStyle = "#FFFFFF";
                context.fillText(text, p[i].sx, p[i].sy);
            }
		}
	},

	drawLightPoint: function(){
		var lightarray = [light];
		project(lightarray);
		var textdata = ("light: " + light.x + "," + light.y + "," + light.z)
		context.fillRect(light.sx, light.sy, 5, 5);
		context.font = "12px Arial";
		context.fillStyle = "#FFFFFF";
		context.fillText(textdata, light.sx, light.sy); 
		//console.log(light.x + ","+ light.y+"," + light.z+","+light.sx+","+light.sy);
	},
	
	drawNormLabel: function(){

		var p  = polyNormalPoints;
		var c = centroids;
        for (var i = 0; i < p.length; i++){
            //scale = fl / (fl + p[i].z + centerZ);
			var n = {x: c[i].x - p[i].x, y: c[i].y - p[i].y, z: c[i].z - p[i].z}; //current vector
			
			var a = {}; //normalized vector
			a.x = n.x/(n.x + n.y + n.z);
			a.y = n.y/(n.x + n.y + n.z);
			a.z = n.z/(n.x + n.y + n.z);
			
            if (p[i].z > clipPlane) {
				
				var text = a.x + ", " + a.y + ", " + a.z;
				context.font = "12px Arial";
				context.fillStyle = "#FFFFFF";
                context.fillText(text, p[i].sx, p[i].sy);
            }
		}
	},
	
	translateLight: function(x, y, z) {
		light.x += x;
		light.y += y;
		light.z += z;
		needsUpdate = true;
	},



	translateModel: function(x, y, z) {
		for(var i = 0; i < points.length; i++) {
			points[i].x += x;
			points[i].y += y;
			points[i].z += z;
		}
		for(var i = 0; i < polyNormalPoints.length; i++) {
			polyNormalPoints[i].x += x;
			polyNormalPoints[i].y += y;
			polyNormalPoints[i].z += z;
			
			centroids[i].x += x;
			centroids[i].y += y;
			centroids[i].z += z;
		}
		needsUpdate = true;
	},

	rotateX: function(angle) {
		var cos = Math.cos(angle),
			sin = Math.sin(angle);

		for(var i = 0; i < points.length; i++) {
			var p = points[i],
				y = p.y * cos - p.z * sin,
				z = p.z * cos + p.y * sin;
			p.y = y;
			p.z = z;
		}
		for(var i = 0; i < polyNormalPoints.length; i++) {
			var p = polyNormalPoints[i],
				y = p.y * cos - p.z * sin,
				z = p.z * cos + p.y * sin;
			p.y = y;
			p.z = z;
		}
		for(var i = 0; i < centroids.length; i++) {
			var p = centroids[i],
				y = p.y * cos - p.z * sin,
				z = p.z * cos + p.y * sin;
			p.y = y;
			p.z = z;
		}
		needsUpdate = true;
	},

	rotateY: function(angle) {
		var cos = Math.cos(angle),
			sin = Math.sin(angle);

		for(var i = 0; i < points.length; i++) {
			var p = points[i],
				x = p.x * cos - p.z * sin,
				z = p.z * cos + p.x * sin;
			p.x = x;
			p.z = z;
		}
		for(var i = 0; i < polyNormalPoints.length; i++) {
			var p = polyNormalPoints[i],
				x = p.x * cos - p.z * sin,
				z = p.z * cos + p.x * sin;
			p.x = x;
			p.z = z;
		}
		for(var i = 0; i < centroids.length; i++) {
			var p = centroids[i],
				x = p.x * cos - p.z * sin,
				z = p.z * cos + p.x * sin;
			p.x = x;
			p.z = z;
		}
		needsUpdate = true;
	},

	rotateZ: function(angle) {
		var cos = Math.cos(angle),
			sin = Math.sin(angle);

		for(var i = 0; i < points.length; i++) {
			var p = points[i],
				x = p.x * cos - p.z * sin,
				z = p.z * cos + p.x * sin;
			p.x = x;
			p.z = z;
		}
		for(var i = 0; i < polyNormalPoints.length; i++) {
			var p = polyNormalPoints[i],
				x = p.x * cos - p.y * sin,
				y = p.y * cos + p.x * sin;
			p.x = x;
			p.y = y;
		}
		for(var i = 0; i < centroids.length; i++) {
			var p = centroids[i],
				x = p.x * cos - p.y * sin,
				y = p.y * cos + p.x * sin;
			p.x = x;
			p.y = y;
		}
		needsUpdate = true;
	},



	readFile: function(file)
	{
		var rawFile = new XMLHttpRequest();
		rawFile.open("GET", file, false);
		rawFile.onreadystatechange = function ()
		{
			if(rawFile.readyState === 4)
			{
				if(rawFile.status === 200 || rawFile.status == 0)
				{
					var allText = rawFile.responseText;
					alert(allText);
                    fileObj = allText.split('\n');

                    console.log(fileObj);
				}
			}
		}
		rawFile.send(null);
		loadModel = false;
	},



    loadVerts: function(fileStr) {
		points = [];
        //tempPoints = [];

        for (var i = 0; i < fileStr.length; i++) {
            var tempLine = [];
            if (fileStr[i][0] === 'v' && fileStr[i][1] === ' ') {
                tempLine.push(fileStr[i].split(' '))
                //console.log(tempLine[0][1]);
            }
            for (var j = 0; j < tempLine.length; j++) {
                points.push({ x: Math.round(tempLine[j][1] * modelScale), y: Math.round(tempLine[j][2] * modelScale), z: Math.round(tempLine[j][3] * modelScale) })
            }
            
        }
        console.log(points);

	},
	
	loadNorms: function(fileStr){
		for (var i = 0; i < fileStr.length; i++) {
			var tempLine = [];

            if (fileStr[i][0] === 'v' && fileStr[i][1] === 'n') {
				//debugger;
                tempLine.push(fileStr[i].split(' '))
                //console.log(tempLine[0][1]);
            }

            for (var j = 0; j < tempLine.length; j++) {
                polyNormals.push({ x: tempLine[j][1], y: tempLine[j][2], z: tempLine[j][3] })
            } 
		}
		
	},

    loadLines: function(fileStr) {
		lines = [];
        tempLines = [];
		polyNormalIndex = [];
        for (var i = 0; i < fileStr.length; i++) {
            var tempLine = [];
            if (fileStr[i][0] === 'f' && fileStr[i][1] === ' ') {
                tempLine.push(fileStr[i].split(' '))
                //console.log(tempLine[0][1][0] + tempLine[0][2][0] + tempLine[0][3][0] + tempLine[0][4][0])
                tempLines.push(tempLine[0]);
            }

        }
        console.log(tempLines);
        //debugger;
        for (var i = 0; i < tempLines.length; i++) {
            var tline = [];
            for (var j = 1; j < tempLines[i].length; j++) {
                var pushStr = tempLines[i][j];
                pushStr = pushStr.substring(0, pushStr.indexOf("/"));
                pushStr -= 1; //offset since obj index starts at 1 instead of 0
                tline.push(pushStr);
            }

			tline.push(tline[0]);

			var pushNorm = tempLines[i][1];
			pushNorm = pushNorm.substring(pushNorm.indexOf("//") + 2);
			pushNorm -= 1;
			polyNormalIndex.push(pushNorm);
			// console.log("tline: " + tline);
            lines.push(tline);
        }

        //console.log(lines);
    },
	
	updateColor: function(color){
		this.lineColor = color.value;
		//console.log(color);
		//console.log(this.lineColor);
	},
	updateWidth: function(width){

		this.lineWidth = width.value;
	},
	updateScale: function(scale){

		this.modelScale = scale.value;
		loadVerts(fileObj);
		loadLines(fileObj);
		
		loadScale = false;
	},
	updateModel: function(fp){

		//fp.setAttribute("type", "file")
		//filePath = "http://localhost:8080/monkey2.obj";
		filePath = fp.files[0].name;
		readFile(filePath);
		//console.log(fp)
		//console.log(filePath)
		loadVerts(fileObj);
		loadNorms(fileObj);
		loadLines(fileObj);
		calcNormPts();
		//fp.value = '';
	},
	// if(!fileLoaded){
		// readFile(filePath);
		// //processFile('file:///H:/Programs/programming/JS/games/3d_tutorial/cube.obj');
		// loadVerts(fileObj);
			
		// loadLines(fileObj);
		// //console.log(fileObj);
	// }
	// modelScale = 1;
	// renderPoints = false,
	// renderNorms = false,
	// update();

	update: function() {

        if (needsUpdate) {
			lc.addEventListener("input", updateColor(lc));
			lw.addEventListener("input", updateWidth(lw));
			if(loadModel){
				fp.addEventListener("input", updateModel(fp));

			}
			if(loadScale)
				ms.addEventListener("input", updateScale(ms));
			// if(!fileLoaded){
				// readFile(filePath);

				// loadVerts(fileObj);
					
				// loadLines(fileObj);
				// fileLoaded = true;
				// //console.log(fileLoaded)
			// }
            context.clearRect(-width / 2, -height / 2, width, height);
			//calcNormal();
			//crossProduct();
					//calcNormPts();
								
								dotProduct();
								lightingCalc(light);
								drawLightPoint();
			project(points);
			project(polyNormalPoints);
			project(centroids);

            // context.beginPath();
			//drawLine(0, 4, 5, 1, 0);

			if(renderPolys){
				drawPoly();
			}
			if(renderLines){
				drawLine();
			}
			if(renderNorms){
				drawNormLine();
				//drawNormLabel();
			}
			if (renderPoints) {
                context.fillStyle = lineColor;
                drawPoints();
            }
			// context.lineWidth = lineWidth;
            // context.strokeStyle = lineColor;
			// context.stroke();

			// var imgData = context.getImageData(0, 0, width, height);
			// context.putImageData(imgData, 50, -100);
			needsUpdate = false;
		}
		requestAnimationFrame(update);
	}
  	}
}
</script>



<style>
	input, label{
		position: static;
		font: 'Arial';
		padding: 5px;
	}
	canvas{
		position: fixed;
		display: block;
	}
		html, body {
		margin: 0px;
        background-color: #1b1c22;
	}

</style>

